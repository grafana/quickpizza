package main

import (
	"context"
	http "net/http"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"

	"log/slog"

	"github.com/grafana/pyroscope-go"
	"github.com/grafana/quickpizza/pkg/database"
	qpgrpc "github.com/grafana/quickpizza/pkg/grpc"
	qphttp "github.com/grafana/quickpizza/pkg/http"
	"github.com/grafana/quickpizza/pkg/logging"
	"github.com/hashicorp/go-retryablehttp"
	"go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
	"go.opentelemetry.io/otel/propagation"
)

func main() {
	// write logs as JSON
	slog.SetDefault(slog.New(slog.NewJSONHandler(os.Stderr, &slog.HandlerOptions{
		Level: logging.GetLogLevel(),
	})))

	// Profiling in pull mode is enabled by default.
	// If QUICKPIZZA_PYROSCOPE_ENDPOINT is set, profiling in push mode will be enabled.
	profilingConfig, profilingEnabled := envPyroscopeConfig()
	if profilingEnabled {
		slog.Info("enabling Pyroscope profiling in Push mode")

		runtime.SetMutexProfileFraction(5)
		runtime.SetBlockProfileRate(5)

		pyroscope.Start(profilingConfig)
	}

	// Enable OpenTelemetry if configured.
	otelInstaller := &qphttp.OTelInstaller{}

	// TODO: use standard OTEL_EXPORTER_OTLP_ENDPOINT env var
	otlpEndpoint, _ := os.LookupEnv("QUICKPIZZA_OTLP_ENDPOINT")
	if otlpEndpoint != "" {
		ctx, cancel := context.WithCancel(context.Background())
		defer cancel()

		var err error
		otelInstaller, err = qphttp.NewOTelInstaller(ctx, otlpEndpoint)
		if err != nil {
			slog.Error("creating OpenTelemetryinstaller", "err", err)
			os.Exit(1)
		}

		slog.Debug("enabling OpenTelemetry tracing and metrics")

		if envBool("QUICKPIZZA_TRUST_CLIENT_TRACEID") {
			otelInstaller.Insecure()
		}
	}

	// Create an HTTP client configured from env vars.
	// If no specific env vars are set, this will return a http client that does not perform any retries.
	httpCli := clientFromEnv()

	// Create the QuickPizza server.
	server := qphttp.NewServer(profilingEnabled, otelInstaller)

	server.AddLivenessProbes()

	// Always add Prometheus handler endpoint.
	server.AddPrometheusHandler()

	// Enable services in this instance. Services are enabled with the following logic:
	// If QUICKPIZZA_ENABLE_ALL_SERVICES is either _not set_ or set to a truthy value, all services are enabled. This is the
	// default behavior.
	// If QUICKPIZZA_ENABLE_ALL_SERVICES is set to a falsy values, services are opted-in by setting the environment variables
	// below to a truty value.

	if envServe("QUICKPIZZA_ENABLE_HTTP_TESTING_SERVICE") {
		server.AddHTTPTesting()
	}

	if envServe("QUICKPIZZA_ENABLE_TEST_K6_IO_SERVICE") {
		server.AddTestK6IO()
	}

	if envServe("QUICKPIZZA_ENABLE_CONFIG_SERVICE") {
		// Prefix for env vars is QUICKPIZZA_CONF_ instead of QUICKPIZZA_CONFIG_ to avoid picking up variables
		// generated by K8s from the pod name.
		server.AddConfigHandler(envConfig("QUICKPIZZA_CONF_"))
	}

	if envServe("QUICKPIZZA_ENABLE_PUBLIC_API_SERVICE") {
		// Serve frontend static assets
		server.AddFrontend()

		// If running as a microservice (not all services in one instance),
		// also act as a gateway to proxy public-facing endpoints
		if !envServeAll() {
			server.AddGateway(
				envEndpoint("QUICKPIZZA_ENABLE_CATALOG_SERVICE", "QUICKPIZZA_CATALOG_ENDPOINT"),
				envEndpoint("QUICKPIZZA_ENABLE_COPY_SERVICE", "QUICKPIZZA_COPY_ENDPOINT"),
				envEndpoint("QUICKPIZZA_ENABLE_WS_SERVICE", "QUICKPIZZA_WS_ENDPOINT"),
				envEndpoint("QUICKPIZZA_ENABLE_RECOMMENDATIONS_SERVICE", "QUICKPIZZA_RECOMMENDATIONS_ENDPOINT"),
				envEndpoint("QUICKPIZZA_ENABLE_CONFIG_SERVICE", "QUICKPIZZA_CONFIG_ENDPOINT"),
			)
		}
	}

	if envServe("QUICKPIZZA_ENABLE_WS_SERVICE") {
		server.AddWebSocket()
	}

	if envServe("QUICKPIZZA_ENABLE_CATALOG_SERVICE") {
		db, err := database.NewCatalog(envDBConnString())
		if err != nil {
			slog.Error("setting up database connection", "err", err)
			os.Exit(1)
		}
		server.AddCatalogHandler(db)
	}

	if envServe("QUICKPIZZA_ENABLE_COPY_SERVICE") {
		db, err := database.NewCopy(envDBConnString())
		if err != nil {
			slog.Error("setting up database connection", "err", err)
			os.Exit(1)
		}
		server.AddCopyHandler(db)
	}

	// Recommendations service needs to know the URL where the Catalog and Copy services are located.
	// This URL is automatically set to `localhost` if Recommendations is enabled at the same time as either of those.
	// If they are not, URLs are sourced from QUICKPIZZA_CATALOG_ENDPOINT and QUICKPIZZA_COPY_ENDPOINT.
	if envServe("QUICKPIZZA_ENABLE_RECOMMENDATIONS_SERVICE") {
		catalogClient := qphttp.NewCatalogClient(envEndpoint("QUICKPIZZA_ENABLE_CATALOG_SERVICE", "QUICKPIZZA_CATALOG_ENDPOINT")).WithClient(httpCli)
		copyClient := qphttp.NewCopyClient(envEndpoint("QUICKPIZZA_ENABLE_COPY_SERVICE", "QUICKPIZZA_COPY_ENDPOINT")).WithClient(httpCli)

		server.AddRecommendations(catalogClient, copyClient)
	}

	if envServe("QUICKPIZZA_ENABLE_GRPC_SERVICE") {
		grpcServer := qpgrpc.NewServer(":3334", ":3335")
		go func() {
			err := grpcServer.ListenAndServe()
			if err != nil {
				slog.Error("Running gRPC server", "err", err)
				os.Exit(1)
			}
		}()
	}

	listen := ":3333"
	slog.Info("Starting QuickPizza", "listenAddress", listen)
	err := http.ListenAndServe(listen, server)
	if err != nil {
		slog.Error("Running HTTP server", "err", err)
		os.Exit(1)
	}
}

// clientFromEnv returns an *http.Client implementation according to the retries and backoff specified in env vars.
func clientFromEnv() *http.Client {
	// Configure an underlying client with otel transport.
	// Otel transport takes care of generating spans for outcoming requests, as well as propagating trace IDs on those
	// requests.
	httpClient := &http.Client{
		Transport: otelhttp.NewTransport(
			nil, // Default transport.
			// Propagator will retrieve the tracer used in the server from memory.
			otelhttp.WithPropagators(propagation.NewCompositeTextMapPropagator(
				propagation.TraceContext{},
				propagation.Baggage{},
			)),
		),
	}

	timeout := envDuration("QUICKPIZZA_TIMEOUT")
	if timeout == 0 {
		timeout = time.Second
	}

	httpClient.Timeout = timeout

	retriableClient := retryablehttp.NewClient()
	retriableClient.Logger = nil
	// Configure retryablehttp to use the instrumented client.
	// Retries occur at the retriableClient layer, so instrumentation will see failures from httpClient.
	retriableClient.HTTPClient = httpClient

	retriableClient.RetryMax = envInt("QUICKPIZZA_RETRIES")

	if retryMin := envDuration("QUICKPIZZA_BACKOFF_MIN"); retryMin != 0 {
		retriableClient.RetryWaitMin = retryMin
	}

	if retryMax := envDuration("QUICKPIZZA_BACKOFF_MAX"); retryMax != 0 {
		retriableClient.RetryWaitMax = retryMax
	}

	// Return a stdlib client that uses retryablehttp as transport.
	return retriableClient.StandardClient()
}

func envPyroscopeConfig() (pyroscope.Config, bool) {
	pyroscopeAddr, ok := os.LookupEnv("QUICKPIZZA_PYROSCOPE_ENDPOINT")
	if !ok {
		return pyroscope.Config{}, false
	}

	svcName, ok := os.LookupEnv("QUICKPIZZA_PYROSCOPE_NAME")
	if !ok {
		svcName, ok = os.LookupEnv("QUICKPIZZA_OTEL_SERVICE_NAME")
		if !ok {
			svcName = "quickpizza"
		}
	}

	svcNamespace, ok := os.LookupEnv("QUICKPIZZA_PYROSCOPE_NAMESPACE")
	if !ok {
		svcNamespace = "quickpizza"
	}

	svcNamespaceLabel, ok := os.LookupEnv("QUICKPIZZA_PYROSCOPE_NAMESPACE_LABEL_NAME")
	if !ok {
		svcNamespaceLabel = "namespace"
	}

	svcGitRef, ok := os.LookupEnv("QUICKPIZZA_PYROSCOPE_SERVICE_GIT_REF")
	if !ok {
		svcGitRef = "refs/heads/main"
	}

	return pyroscope.Config{
		ApplicationName: svcName,
		ServerAddress:   pyroscopeAddr,

		BasicAuthUser:     os.Getenv("QUICKPIZZA_GRAFANA_CLOUD_USER"),
		BasicAuthPassword: os.Getenv("QUICKPIZZA_GRAFANA_CLOUD_PASSWORD"),

		// make configurable?
		ProfileTypes: []pyroscope.ProfileType{
			// these profile types are enabled by default:
			pyroscope.ProfileCPU,
			pyroscope.ProfileAllocObjects,
			pyroscope.ProfileAllocSpace,
			pyroscope.ProfileInuseObjects,
			pyroscope.ProfileInuseSpace,

			// these profile types are optional:
			pyroscope.ProfileGoroutines,
			pyroscope.ProfileMutexCount,
			pyroscope.ProfileMutexDuration,
			pyroscope.ProfileBlockCount,
			pyroscope.ProfileBlockDuration,
		},

		Tags: map[string]string{
			svcNamespaceLabel:    svcNamespace,
			"service_git_ref":    svcGitRef,
			"service_repository": "https://github.com/grafana/quickpizza",
		},
	}, true
}

func envServeAll() bool {
	allSvcs, present := os.LookupEnv("QUICKPIZZA_ENABLE_ALL_SERVICES")
	allSvcsB, _ := strconv.ParseBool(allSvcs)

	// If QUICKPIZZA_ENABLE_ALL_SERVICES is not defined (default), serve everything.
	if !present {
		return true
	}

	// Otherwise, serve all if QUICKPIZZA_ENABLE_ALL_SERVICES is truthy.
	return allSvcsB
}

// envServe returns whether a service should be enabled.
func envServe(name string) bool {
	return envServeAll() || envBool(name)
}

// envEndpoint returns the endpoint URL for a service.
// If the service is enabled (envServe(svcEnv) == true), it returns "http://localhost:3333".
// Otherwise, it returns the value of the endpointEnv environment variable.
func envEndpoint(svcEnv, endpointEnv string) string {
	if envServe(svcEnv) {
		return "http://localhost:3333"
	}

	endpoint, _ := os.LookupEnv(endpointEnv)
	return endpoint
}

// envBool returns true if an env var is set and has a truthy value.
func envBool(name string) bool {
	v, found := os.LookupEnv(name)
	if !found {
		return false
	}

	b, err := strconv.ParseBool(v)
	if err != nil {
		return false
	}

	return b
}

// envInt returns the 32-bit integer value for the specified env var, or 0 if it is not set or cannot be parsed.
func envInt(name string) int {
	v, found := os.LookupEnv(name)
	if !found {
		return 0
	}

	b, err := strconv.ParseInt(v, 10, 32)
	if err != nil {
		return 0
	}

	return int(b)
}

// envInt returns the time.Duration value for the specified env var, or 0 if it is not set or cannot be parsed.
func envDuration(name string) time.Duration {
	v, found := os.LookupEnv(name)
	if !found {
		return 0
	}

	d, err := time.ParseDuration(v)
	if err != nil {
		return 0
	}

	return d
}

// envConfig reads environment variables matching prefix, and returns them as a map with the prefix stripped.
// TODO: Convert variable names to camelCase in the returned map.
func envConfig(prefix string) map[string]string {
	config := make(map[string]string)

	for _, envVar := range os.Environ() {
		// os.Environ returns vars in key=value form.
		nameValue := strings.Split(envVar, "=")
		if len(nameValue) < 2 {
			continue // This should be impossible as per the contract of os.Environ.
		}

		name := nameValue[0]
		value := nameValue[1]

		if !strings.HasPrefix(name, prefix) {
			continue
		}

		name = strings.ToLower(strings.TrimPrefix(name, prefix))
		config[strings.ToLower(name)] = value
	}

	return config
}

// envDBConnString returns the specified db connection string from QUICKPIZZA_DB. It defaults to an in-memory sqlite instance
func envDBConnString() string {
	v, found := os.LookupEnv("QUICKPIZZA_DB")
	if !found {
		return "file::memory:?cache=shared"
	}
	return v
}
